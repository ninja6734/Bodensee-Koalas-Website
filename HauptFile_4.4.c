#pragma config(Sensor, S2,     ,               sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     ,               sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          A,             tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          B,             tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          C,             tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h"
tHTIRS2 Seeker_P;
#include "hitechnic-compass.h"
tHTMC Kompass_P;

//Enistellungs Variablen
int FieldWidth = 121   -10;
int FieldHeight = 181  -10;
int Speed_A = 80 ;
int Speed_D = 80 ;
int Speed_B = 100 ;
int Drib_Norm = 200 ;
int Kord_Num = 3;

// System Variablen
bool motor_deturn=false;
int Seeker ;
int Kompass ;
int Drib_Speed ;
int Offset_Heading ;
string  status  ;
int Distanz_seite = 0;
int Distanz_vorne = 0;
int sizeOfWidthFields = round(FieldWidth / Kord_Num);
int sizeOfHeightFields = round(FieldHeight / Kord_Num);
int FieldX;
int FieldY;
int X_Speed;
int Y_Speed;
int Position;
int motor_sets;
int returner;
int lastXPos;
int lastYPos;
int Ballturn;
int lastturndirection=1;
bool korektionturn=true;
string Direktion;
int timer ;
int KompAusrichten;

/*
Sensoren:
port 1: Kompass
port 2: Ultra schall seite
port 3: Ultraschall nach hinten
port 4: Ballsuche

Motore:
port A: rechter Motor
port B: Dribbler
port C: leer
port D: linker Motor
*/
//Zum Tor Drehen f?r Radar

void  Read_Sensors(){
	//gibt true zurï¿½ck falls es geklappt hat und false falls nicht
  readSensor (&Seeker_P);
	readSensor (&Kompass_P);

	Drib_Speed = getMotorRPM(motorB);

	// Ultra einlesen
	Distanz_seite = getUSDistance(S2);
	Distanz_vorne = getUSDistance(S3);

	Seeker = Seeker_P.acDirection;
	Kompass = Kompass_P.relativeHeading;

	displayBigTextLine   (1,"timer: %d",timer);
	displayBigTextLine   (3,"seeker: %d",Seeker);
	displayBigTextLine   (5,"Komp: %d",Kompass);
	displayBigTextLine   (7,"Posi: %d",Position);
	displayBigTextLine   (9,"Ausr.: %d",KompAusrichten);
}

void Motor (int x,int y){
	setMotorSpeed  (motorA,x);
	setMotorSpeed  (motorD,y);
}

void Kordinate(){

	//Rechts
	if      (Position == 9){
		X_Speed = Speed_A;
		Y_Speed = 0;
	}
	else if (Position == 8){
		X_Speed = Speed_A-30;
		Y_Speed = Speed_D;
	}
	else if (Position == 7){
		Direktion = "Rechts";
		X_Speed = 0;
		Y_Speed = Speed_B;
	}
	else if (Position == 4){
		X_Speed = Speed_A;
		Y_Speed = Speed_D;
	}
	else if (Position == 5){
		X_Speed = Speed_A;
		Y_Speed = Speed_D;
	}
	else if (Position == 6){
		X_Speed = Speed_A;
		Y_Speed = Speed_D-30;
	}
  else if (Position == 1){
	  X_Speed = Speed_A;
		Y_Speed = Speed_D;
	}
	else if (Position == 3){
		X_Speed = Speed_A;
		Y_Speed = Speed_D;
	}
	else if (Position == 2){
		X_Speed = Speed_A;
		Y_Speed = Speed_D;
	}
	Motor(X_Speed,Y_Speed);
}

void Radar(){
	if (Distanz_seite > FieldWidth ){
		Distanz_seite = FieldWidth;
	}
	if (Distanz_vorne > FieldHeight ){
		Distanz_vorne = FieldHeight;
	}
	FieldX = ceil((Distanz_seite / sizeOfWidthFields)+0.01);
	FieldY = ceil((Distanz_vorne / sizeOfHeightFields)+0.01);
	if (FieldX > 3 ){
		FieldX = 3;
	}
	if (FieldY > 3 ){
		FieldY = 3;
	}
	Position = FieldX+Kord_Num*(FieldY-1);
}

void BallGot(){
	//if (KompAusrichten==true){
		if ((Kompass<10)&&(Kompass>-10)){
			Radar();
			Kordinate();
			motor_deturn=true;
		//	KompAusrichten=false;
		}
		else {
			if(FieldX == 3){
				Motor(20,-20);
			}
			else{
				Motor(-20,20);
			}
			motor_deturn=false;
		//	KompAusrichten=true;
		}
}

void  Ball (){
	KompAusrichten=true;
	if (Seeker==4){
		lastturndirection=1; 
		korektionturn = false;
		Motor(-(Speed_A/8),(Speed_D/8));
	}
	else if (Seeker==6){
		lastturndirection=2;
		korektionturn = false;
		Motor((Speed_A/8),-(Speed_D/8));
	}
	else if (Seeker<4){
		lastturndirection=1;
		korektionturn = false;
		Motor(-(Speed_A/2),(Speed_D/2));
	}
	else if (Seeker>6){
		lastturndirection=2;
		korektionturn = false;
		Motor((Speed_A/2),-(Speed_D/2));
	}
	else  if (Seeker==5){
   		if (korektionturn == false) {
				if (lastturndirection == 2){
					Motor(50,-50);
					wait1Msec(40);
					Motor(0,0);
				}
				else if (lastturndirection == 1){
					Motor(-50,50);
					wait1Msec(40);
					Motor(0,0);
				}
		  }
		else {
		       Motor(Speed_A,Speed_D);
		}
		korektionturn = true;
	}
}

void  Main_Switch () {

	if (Drib_Speed >= Drib_Norm){
		status = "Ball";
		Ball();
	}
	else if ( Drib_Speed > 0) {
		status = "Tor";
		BallGot();
	}
}

task main (){
	initSensor (&Kompass_P, S1);
	initSensor (&Seeker_P, S4);
	readSensor (&Kompass_P);

	//Ich glaub das hei?t heading nicht Heading.
	Offset_Heading = Kompass_P.Heading;
	Kompass_P.offset = Offset_Heading;
	//Brute force bei Anspiel

	setMotorSpeed(motorB,Speed_B);

	Motor(100,100);

	wait1Msec(800);

	while (true ){
		if (motor_deturn==false){
			setMotorSpeed(motorB,Speed_B);
		}
		else {
			setMotorSpeed(motorB,-Speed_B);
		}
		Read_Sensors();
		Main_Switch();
		wait1Msec(100);
	}
}
